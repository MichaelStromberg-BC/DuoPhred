/** fft.c **/

/*
*|***************************************************************************|*
*|                                                                           |*
*|   Program: phred                                                          |*
*|   Version: 0.000925.c                                                     |*
*|                                                                           |*
*|   Copyright (C) 1993-2000 by Phil Green and Brent Ewing.                  |*
*|   All rights reserved.                                                    |*
*|                                                                           |*
*|   This software is a beta-test version of the phred package.              |*
*|   It should not be redistributed or used for any commercial               |*
*|   purpose, including commercially funded sequencing, without              |*
*|   written permission from the author and the University of                |*
*|   Washington.                                                             |*
*|                                                                           |*
*|   This software is provided ``AS IS'' and any express or                  |*
*|   implied warranties, including, but not limited to, the                  |*
*|   implied warranties of merchantability and fitness for a                 |*
*|   particular purpose, are disclaimed.  In no event shall                  |*
*|   the authors or the University of Washington be liable for               |*
*|   any direct, indirect, incidental, special, exemplary, or                |*
*|   consequential damages (including, but not limited to,                   |*
*|   procurement of substitute goods or services; loss of use,               |*
*|   data, or profits; or business interruption) however caused              |*
*|   and on any theory of liability, whether in contract, strict             |*
*|   liability, or tort (including negligence or otherwise)                  |*
*|   arising in any way out of the use of this software, even                |*
*|   if advised of the possibility of such damage.                           |*
*|                                                                           |*
*|   Portions of the code benefit from ideas due to Dave Ficenec,            |*
*|   LaDeana Hillier, Mike Wendl, and Tim Gleeson.  These are                |*
*|   indicated in the relevant source files.                                 |*
*|                                                                           |*
*|***************************************************************************|*
*/

/*
*******************************************************************************
**                                                                           **
**    * Dave Ficenec of the GSC provided advice for modifications       *    **
**    * to the function max_from_fft() that allow phred to reliably     *    **
**    * process data generated by the ABI 377 sequencer.                *    **
**                                                                           **
*******************************************************************************
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "phred.h"

#define SWAP(a,b) tempr=(a);(a)=(b);(b)=tempr

#ifdef ANSI_C
static int four1( FLOAT *data, int nn, int isign )
#else
static int four1( data, nn, isign )
FLOAT data[];
int nn,isign;
#endif
{
  int n,mmax,m,j,istep,i;
  double wtemp,wr,wpr,wpi,wi,theta;
  FLOAT tempr,tempi;

  n = nn << 1;
  j = 1;
  for (i = 1; i < n; i += 2) {
    if (j > i) {
      SWAP(data[j],data[i]);
      SWAP(data[j + 1], data[i + 1]);
    }
    m = n >> 1;
    while (m >= 2 && j > m) {
      j -= m;
      m >>= 1;
    }
    j += m;
  }
  mmax = 2;
  while (n > mmax) {
    istep = 2 * mmax;
    theta = 6.28318530717959/(isign * mmax);
    wtemp = sin(0.5 * theta);
    wpr = -2.0 * wtemp *wtemp;
    wpi = sin(theta);
    wr = 1.0;
    wi = 0.0;
    for (m = 1; m < mmax; m+=2) {
      for (i = m; i <= n; i += istep) {
	j = i + mmax;
	tempr = wr * data[j] - wi * data[j + 1];
	tempi = wr * data[j + 1] + wi * data[j];
	data[j] = data[i] - tempr;
	data[j + 1] = data[i + 1] - tempi;
	data[i] += tempr;
	data[i + 1] += tempi;
      }
      wr = (wtemp = wr) * wpr - wi * wpi + wr;
      wi = wi * wpr + wtemp * wpi + wi;
    }
    mmax = istep;
  }
  return( 0 );
}

#ifdef ANSI_C
static int realft( FLOAT *data, int n, int isign )
#else
static int realft( data, n, isign )
FLOAT data[];
int n,isign;
#endif
{
  int i,i1,i2,i3,i4,n2p3;
  FLOAT c1,c2,h1r,h1i,h2r,h2i;
  double wr,wi,wpr,wpi,wtemp,theta;

  c1 = 0.5;
  theta = 3.141592653589793/(double)n;
  if (isign == 1) {
    c2 = -0.5;
    four1(data,n,1);
  }
  else {
    c2 = 0.5;
    theta = -theta;
  }
  wtemp = sin(0.5 * theta);
  wpr = -2.0 * wtemp * wtemp;
  wpi = sin(theta);
  wr = 1.0 + wpr;
  wi = wpi;
  n2p3 = 2 * n + 3;
  for (i = 2; i <= n/2; i++) {
    i4 = 1 + (i3 = n2p3 - (i2 = 1 + (i1 = i + i - 1)));
    h1r = c1 * (data[i1] + data[i3]);
    h1i = c1 * (data[i2] - data[i4]);
    h2r = -c2 * (data[i2] + data[i4]);
    h2i = c2 * (data[i1] - data[i3]);
    data[i1] = h1r + wr * h2r - wi * h2i;
    data[i2] = h1i + wr * h2i + wi * h2r;
    data[i3] = h1r -wr * h2r + wi * h2i;
    data[i4] = -h1i + wr * h2i + wi * h2r;
    wr = (wtemp = wr) * wpr - wi * wpi + wr;
    wi = wi * wpr + wtemp * wpi + wi;
  }
  if (isign == 1) {
    data[1] = (h1r = data[1]) + data[2];
    data[2] = h1r - data[2];
  }
  else {
    data[1] = c1 * ((h1r = data[1]) + data[2]);
    data[2] = c1 * (h1r - data[2]);
    four1(data,n,-1);
  }
  return( 0 );
}



  
#ifdef ANSI_C
int max_from_fft( FLOAT *vec, int length, FLOAT *period,
                  FLOAT *value, FLOAT start_check, FLOAT end_check )
#else
int max_from_fft( vec, length, period, value, start_check, end_check )
FLOAT *vec;
int length;
FLOAT *period,*value;
FLOAT start_check,end_check;
#endif
{
  int i,j;
  FLOAT fft_temp[4096];
  FLOAT temp, max;


  for (j = 0; j < length; j++) fft_temp[j] = vec[j];
  /*
  ** replaced 4096 by 2048 and 2048 by 1024
  */
  for (;j < 2048; j++)
  {
    fft_temp[j] = 0.0;
  }
  realft(fft_temp - 1,1024,1);
  max = 0.0;
/*
**
** Original...restricts search for peak.
**
  for (i = 2048/start_check + 1; i >= 2048/end_check; i--)
**
** Search most all of the transform for the largest peak...
*/
  for (i = 4; i < 1020; i++)
  {
    temp = fft_temp[2 * i] * fft_temp[2 * i] +
           fft_temp[2*i+1] * fft_temp[2*i+1];
    if( temp > max )
    {
      *period = 2048.0/(FLOAT)i;
      max = temp;
    }
  }
  *value = (FLOAT)sqrt( (double)max );

  return( 0 );
}    
